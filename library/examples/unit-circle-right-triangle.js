/**
* An interactive to demonstrate how the radius of a circle can be used to
* measure the angle between two rays.
*
* June 9, 2019
* Kurt Bruns
*/
import Interactive from '../Interactive.js';
// Initialize the interactive
let id = 'unit-circle-right-triangle';
let interactive = new Interactive(id);
interactive.window = false;
interactive.width = 320;
interactive.height = 320;
interactive.originX = interactive.width / 2;
interactive.originY = interactive.height / 2;
// Create a circle
let circle = interactive.circle(0, 0, 100);
// Create a control
let control = interactive.control(circle.r * Math.cos(-1), circle.r * Math.sin(-1));
control.constrainToCircle(circle.cx, circle.cy, circle.r);
// Create a path
let path = interactive.path('');
path.root.style.fill = 'gray';
path.root.style.fillOpacity = '.3';
path.update = function () {
    let flag = (control.y > 0) ? 1 : 0;
    path.d = `M 0 0
            L ${control.x} 0
            L ${control.x} ${control.y}
            z`;
};
path.update();
path.addDependency(control);
// Create a point at the origin
let point = interactive.circle(0, 0, 3);
point.fill = 'black';
// Gets the normalized angle between zero and tau. TODO: Maybe transform the
// coordinate system so that the positive y-direction is up instead of down.
// UPDATE: transform = 'scale(1,-1)' applied to the main svg  didn't quite work
// as expected: the text element was upside down, but maybe that could be
// reversed? bleh.
function getAngle() {
    if (control.y <= 0) {
        return Math.abs(Math.atan2(control.y, control.x));
    }
    else {
        return Math.PI * 2 - Math.atan2(control.y, control.x);
    }
}
// Create text to display the current angle. TODO: add a check-box to change
// between radians and degrees
let text = interactive.text(0, 130, "test");
text.addDependency(control);
text.update = function () {
    text.contents = `angle = ${getAngle().toFixed(3)}`;
};
text.update();
text.x = -text.root.textLength.baseVal.value / 2;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidW5pdC1jaXJjbGUtcmlnaHQtdHJpYW5nbGUuanMiLCJzb3VyY2VSb290IjoiLi9zb3VyY2UvIiwic291cmNlcyI6WyJleGFtcGxlcy91bml0LWNpcmNsZS1yaWdodC10cmlhbmdsZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0VBTUU7QUFFRixPQUFPLFdBQVcsTUFBTSxtQkFBbUIsQ0FBQztBQUU1Qyw2QkFBNkI7QUFDN0IsSUFBSSxFQUFFLEdBQUcsNEJBQTRCLENBQUM7QUFDdEMsSUFBSSxXQUFXLEdBQUcsSUFBSSxXQUFXLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDdEMsV0FBVyxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7QUFDM0IsV0FBVyxDQUFDLEtBQUssR0FBRyxHQUFHLENBQUM7QUFDeEIsV0FBVyxDQUFDLE1BQU0sR0FBRyxHQUFHLENBQUM7QUFDekIsV0FBVyxDQUFDLE9BQU8sR0FBRyxXQUFXLENBQUMsS0FBSyxHQUFDLENBQUMsQ0FBQztBQUMxQyxXQUFXLENBQUMsT0FBTyxHQUFHLFdBQVcsQ0FBQyxNQUFNLEdBQUMsQ0FBQyxDQUFDO0FBRTNDLGtCQUFrQjtBQUNsQixJQUFJLE1BQU0sR0FBRyxXQUFXLENBQUMsTUFBTSxDQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFFNUMsbUJBQW1CO0FBQ25CLElBQUksT0FBTyxHQUFHLFdBQVcsQ0FBQyxPQUFPLENBQUUsTUFBTSxDQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNqRixPQUFPLENBQUMsaUJBQWlCLENBQUUsTUFBTSxDQUFDLEVBQUUsRUFBRSxNQUFNLENBQUMsRUFBRSxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUUzRCxnQkFBZ0I7QUFDaEIsSUFBSSxJQUFJLEdBQUcsV0FBVyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUNoQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEdBQUcsTUFBTSxDQUFDO0FBQzlCLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUM7QUFDbkMsSUFBSSxDQUFDLE1BQU0sR0FBRztJQUNaLElBQUksSUFBSSxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDbkMsSUFBSSxDQUFDLENBQUMsR0FBRztnQkFDSyxPQUFPLENBQUMsQ0FBQztnQkFDVCxPQUFPLENBQUMsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxDQUFDO2NBQ3hCLENBQUM7QUFDZixDQUFDLENBQUM7QUFDRixJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7QUFDZCxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBRTVCLCtCQUErQjtBQUMvQixJQUFJLEtBQUssR0FBRyxXQUFXLENBQUMsTUFBTSxDQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDekMsS0FBSyxDQUFDLElBQUksR0FBRyxPQUFPLENBQUM7QUFFckIsNEVBQTRFO0FBQzVFLDRFQUE0RTtBQUM1RSwrRUFBK0U7QUFDL0UseUVBQXlFO0FBQ3pFLGtCQUFrQjtBQUNsQixTQUFTLFFBQVE7SUFDZixJQUFJLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFHO1FBQ25CLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFFLE9BQU8sQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDcEQ7U0FBTTtRQUNMLE9BQU8sSUFBSSxDQUFDLEVBQUUsR0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBRSxPQUFPLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUN0RDtBQUNILENBQUM7QUFFRCw0RUFBNEU7QUFDNUUsOEJBQThCO0FBQzlCLElBQUksSUFBSSxHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxNQUFNLENBQUMsQ0FBQztBQUM3QyxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzVCLElBQUksQ0FBQyxNQUFNLEdBQUc7SUFDWixJQUFJLENBQUMsUUFBUSxHQUFHLFdBQVcsUUFBUSxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7QUFDckQsQ0FBQyxDQUFDO0FBQ0YsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO0FBQ2QsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEdBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4qIEFuIGludGVyYWN0aXZlIHRvIGRlbW9uc3RyYXRlIGhvdyB0aGUgcmFkaXVzIG9mIGEgY2lyY2xlIGNhbiBiZSB1c2VkIHRvXG4qIG1lYXN1cmUgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIHJheXMuXG4qXG4qIEp1bmUgOSwgMjAxOVxuKiBLdXJ0IEJydW5zXG4qL1xuXG5pbXBvcnQgSW50ZXJhY3RpdmUgZnJvbSAnLi4vSW50ZXJhY3RpdmUuanMnO1xuXG4vLyBJbml0aWFsaXplIHRoZSBpbnRlcmFjdGl2ZVxubGV0IGlkID0gJ3VuaXQtY2lyY2xlLXJpZ2h0LXRyaWFuZ2xlJztcbmxldCBpbnRlcmFjdGl2ZSA9IG5ldyBJbnRlcmFjdGl2ZShpZCk7XG5pbnRlcmFjdGl2ZS53aW5kb3cgPSBmYWxzZTtcbmludGVyYWN0aXZlLndpZHRoID0gMzIwO1xuaW50ZXJhY3RpdmUuaGVpZ2h0ID0gMzIwO1xuaW50ZXJhY3RpdmUub3JpZ2luWCA9IGludGVyYWN0aXZlLndpZHRoLzI7XG5pbnRlcmFjdGl2ZS5vcmlnaW5ZID0gaW50ZXJhY3RpdmUuaGVpZ2h0LzI7XG5cbi8vIENyZWF0ZSBhIGNpcmNsZVxubGV0IGNpcmNsZSA9IGludGVyYWN0aXZlLmNpcmNsZSggMCwgMCwgMTAwKTtcblxuLy8gQ3JlYXRlIGEgY29udHJvbFxubGV0IGNvbnRyb2wgPSBpbnRlcmFjdGl2ZS5jb250cm9sKCBjaXJjbGUucipNYXRoLmNvcygtMSksIGNpcmNsZS5yKk1hdGguc2luKC0xKSk7XG5jb250cm9sLmNvbnN0cmFpblRvQ2lyY2xlKCBjaXJjbGUuY3gsIGNpcmNsZS5jeSwgY2lyY2xlLnIpO1xuXG4vLyBDcmVhdGUgYSBwYXRoXG5sZXQgcGF0aCA9IGludGVyYWN0aXZlLnBhdGgoJycpO1xucGF0aC5yb290LnN0eWxlLmZpbGwgPSAnZ3JheSc7XG5wYXRoLnJvb3Quc3R5bGUuZmlsbE9wYWNpdHkgPSAnLjMnO1xucGF0aC51cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgbGV0IGZsYWcgPSAoY29udHJvbC55ID4gMCkgPyAxIDogMDtcbiAgcGF0aC5kID0gYE0gMCAwXG4gICAgICAgICAgICBMICR7Y29udHJvbC54fSAwXG4gICAgICAgICAgICBMICR7Y29udHJvbC54fSAke2NvbnRyb2wueX1cbiAgICAgICAgICAgIHpgO1xufTtcbnBhdGgudXBkYXRlKCk7XG5wYXRoLmFkZERlcGVuZGVuY3koY29udHJvbCk7XG5cbi8vIENyZWF0ZSBhIHBvaW50IGF0IHRoZSBvcmlnaW5cbmxldCBwb2ludCA9IGludGVyYWN0aXZlLmNpcmNsZSggMCwgMCwgMyk7XG5wb2ludC5maWxsID0gJ2JsYWNrJztcblxuLy8gR2V0cyB0aGUgbm9ybWFsaXplZCBhbmdsZSBiZXR3ZWVuIHplcm8gYW5kIHRhdS4gVE9ETzogTWF5YmUgdHJhbnNmb3JtIHRoZVxuLy8gY29vcmRpbmF0ZSBzeXN0ZW0gc28gdGhhdCB0aGUgcG9zaXRpdmUgeS1kaXJlY3Rpb24gaXMgdXAgaW5zdGVhZCBvZiBkb3duLlxuLy8gVVBEQVRFOiB0cmFuc2Zvcm0gPSAnc2NhbGUoMSwtMSknIGFwcGxpZWQgdG8gdGhlIG1haW4gc3ZnICBkaWRuJ3QgcXVpdGUgd29ya1xuLy8gYXMgZXhwZWN0ZWQ6IHRoZSB0ZXh0IGVsZW1lbnQgd2FzIHVwc2lkZSBkb3duLCBidXQgbWF5YmUgdGhhdCBjb3VsZCBiZVxuLy8gcmV2ZXJzZWQ/IGJsZWguXG5mdW5jdGlvbiBnZXRBbmdsZSgpIHtcbiAgaWYoIGNvbnRyb2wueSA8PSAwICkge1xuICAgIHJldHVybiBNYXRoLmFicyhNYXRoLmF0YW4yKCBjb250cm9sLnksIGNvbnRyb2wueCkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBNYXRoLlBJKjIgLSBNYXRoLmF0YW4yKCBjb250cm9sLnksIGNvbnRyb2wueCk7XG4gIH1cbn1cblxuLy8gQ3JlYXRlIHRleHQgdG8gZGlzcGxheSB0aGUgY3VycmVudCBhbmdsZS4gVE9ETzogYWRkIGEgY2hlY2stYm94IHRvIGNoYW5nZVxuLy8gYmV0d2VlbiByYWRpYW5zIGFuZCBkZWdyZWVzXG5sZXQgdGV4dCA9IGludGVyYWN0aXZlLnRleHQoIDAsIDEzMCwgXCJ0ZXN0XCIpO1xudGV4dC5hZGREZXBlbmRlbmN5KGNvbnRyb2wpO1xudGV4dC51cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgdGV4dC5jb250ZW50cyA9IGBhbmdsZSA9ICR7Z2V0QW5nbGUoKS50b0ZpeGVkKDMpfWA7XG59O1xudGV4dC51cGRhdGUoKTtcbnRleHQueCA9IC10ZXh0LnJvb3QudGV4dExlbmd0aC5iYXNlVmFsLnZhbHVlLzI7XG4iXX0=